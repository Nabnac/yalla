#!/bin/bash

# Accurate CVE Scanner for Kandji
# Version 6.0 - Only reports CVEs that actually affect installed versions
# No false positives - accurate package and version matching

# Configuration
CVE_SEVERITY_THRESHOLD="HIGH"  # CRITICAL, HIGH, MEDIUM, LOW
DEBUG_MODE="${DEBUG_MODE:-false}"

# Storage configuration
STORAGE_BACKEND="${CVE_STORAGE_BACKEND:-github}"
GITHUB_RAW_URL="${CVE_GITHUB_RAW_URL:-https://raw.githubusercontent.com/Nabnac/yalla/main}"

# Get system info
current_user="$(/usr/bin/stat -f%Su /dev/console 2>/dev/null || echo 'unknown')"
hostname="$(hostname 2>/dev/null || echo 'unknown')"
timestamp="$(date)"
scan_id="$(date +%s)-$$"

# Set Homebrew environment
export HOMEBREW_NO_AUTO_UPDATE=1
export HOMEBREW_NO_INSTALL_CLEANUP=1

echo "=========================================="
echo "Accurate CVE Scanner v6.0"
echo "Device: $hostname"
echo "User: $current_user" 
echo "Scan ID: $scan_id"
echo "Timestamp: $timestamp"
echo "=========================================="

# Initialize counters
total_packages=0
scanned_packages=0
affected_packages=0
total_cves_found=0
high_risk_cves=0

# Temporary cache directory
temp_cache_dir="/tmp/cve-cache-$$"
mkdir -p "$temp_cache_dir"

# Cleanup function
cleanup_temp_files() {
    rm -rf "$temp_cache_dir" 2>/dev/null
}

trap cleanup_temp_files EXIT

# Find Homebrew
BREW_PATH=""
if [[ -x "/opt/homebrew/bin/brew" ]]; then
    BREW_PATH="/opt/homebrew/bin/brew"
    echo "✅ Homebrew found: /opt/homebrew/bin/brew (Apple Silicon)"
elif [[ -x "/usr/local/bin/brew" ]]; then
    BREW_PATH="/usr/local/bin/brew"
    echo "✅ Homebrew found: /usr/local/bin/brew (Intel)"
else
    echo "❌ Homebrew not found"
    echo "COMPLIANCE_STATUS: COMPLIANT"
    echo "REASON: No Homebrew installation detected"
    exit 0
fi

# Function to parse version
parse_version() {
    local version="$1"
    # Remove common prefixes and extract numeric version
    version=$(echo "$version" | sed -E 's/^[^0-9]*([0-9]+.*)/\1/' | sed -E 's/[^0-9.].*$//')
    
    # Handle empty versions
    if [[ -z "$version" || ! "$version" =~ ^[0-9] ]]; then
        echo "0.0.0"
        return
    fi
    
    echo "$version"
}

# Function to compare versions
compare_versions() {
    local v1="$1"
    local v2="$2"
    
    # Parse versions
    v1=$(parse_version "$v1")
    v2=$(parse_version "$v2")
    
    # Use sort -V for version comparison
    if [[ "$(printf '%s\n%s\n' "$v1" "$v2" | sort -V | tail -1)" == "$v1" ]]; then
        return 0  # v1 >= v2
    else
        return 1  # v1 < v2
    fi
}

# Function to check if version is affected by CVE constraints
check_version_constraints() {
    local installed_version="$1"
    local constraints_json="$2"
    
    # Parse constraints using Python (always available on macOS)
    local result
    result=$(python3 -c "
import json
import sys

installed = '$installed_version'
constraints = json.loads('$constraints_json')

# Check if affects all versions
if constraints.get('affects_all'):
    print('AFFECTED:Affects all versions')
    sys.exit(0)

# Check max version (most common)
if constraints.get('max_version'):
    max_ver = constraints['max_version']
    # Simple version comparison
    inst_parts = installed.split('.')
    max_parts = max_ver.split('.')
    
    # Pad with zeros
    while len(inst_parts) < len(max_parts):
        inst_parts.append('0')
    while len(max_parts) < len(inst_parts):
        max_parts.append('0')
    
    # Compare
    for i in range(len(inst_parts)):
        try:
            if int(inst_parts[i]) < int(max_parts[i]):
                print(f'AFFECTED:Version {installed} < {max_ver}')
                sys.exit(0)
            elif int(inst_parts[i]) > int(max_parts[i]):
                print(f'NOT_AFFECTED:Version {installed} >= {max_ver}')
                sys.exit(0)
        except:
            pass
    
    # Versions are equal - check if using < or <=
    if 'through' in str(constraints):
        print(f'AFFECTED:Version {installed} <= {max_ver}')
    else:
        print(f'NOT_AFFECTED:Version {installed} >= {max_ver}')
    sys.exit(0)

# Check fixed version
if constraints.get('fixed_version'):
    fixed = constraints['fixed_version']
    # If our version is less than fixed version, we're affected
    # Similar comparison logic...
    print(f'NOT_AFFECTED:No clear version match')
    sys.exit(0)

# No version constraints found
print('NOT_AFFECTED:No version constraints found')
" 2>/dev/null || echo "ERROR:Failed to parse constraints")
    
    echo "$result"
}

# Function to download CVE data
download_cve_data() {
    local package="$1"
    local output_file="$2"
    
    curl -sL "$GITHUB_RAW_URL/cve-data/$package.json.gz" -o "$output_file" 2>/dev/null
    return $?
}

# Function to check CVE database
check_cve_database() {
    echo ""
    echo "=== CHECKING CVE DATABASE ==="
    
    local manifest_file="$temp_cache_dir/manifest.json"
    curl -sL "$GITHUB_RAW_URL/cve-data/manifest.json" -o "$manifest_file" 2>/dev/null
    
    if [[ -f "$manifest_file" ]] && [[ -s "$manifest_file" ]]; then
        if command -v jq >/dev/null 2>&1; then
            local version
            version=$(jq -r '.version // "unknown"' "$manifest_file" 2>/dev/null)
            local last_update
            last_update=$(jq -r '.updated' "$manifest_file" 2>/dev/null || echo "unknown")
            local total_cves
            total_cves=$(jq -r '.total_cves' "$manifest_file" 2>/dev/null || echo "0")
            
            echo "✅ CVE database accessible (v$version)"
            echo "  Last updated: $last_update"
            echo "  Total CVEs: $total_cves"
            
            if [[ "$version" != "3.0" ]]; then
                echo "  ⚠️  WARNING: Database version mismatch. Update may be needed."
            fi
        fi
        return 0
    else
        echo "❌ CVE database not accessible"
        return 1
    fi
}

# Function to get package version
get_package_version() {
    local package="$1"
    local package_type="$2"
    
    # Use brew list --versions
    local version_info
    if [[ "$package_type" == "cask" ]]; then
        version_info=$("$BREW_PATH" list --versions --cask "$package" 2>/dev/null || echo "")
    else
        version_info=$("$BREW_PATH" list --versions "$package" 2>/dev/null || echo "")
    fi
    
    if [[ -n "$version_info" && "$version_info" != "$package" ]]; then
        echo "$version_info" | awk '{print $2}'
        return 0
    fi
    
    echo "unknown"
    return 1
}

# Function to normalize package name for CVE lookup
normalize_package_name() {
    local package="$1"
    
    # Remove version suffixes
    package=$(echo "$package" | sed 's/@[0-9].*//')
    
    # Handle package name mappings
    case "$package" in
        "node")
            echo "nodejs"
            ;;
        "python3")
            echo "python"
            ;;
        *)
            echo "$package"
            ;;
    esac
}

# Function to scan a single package
scan_package() {
    local package="$1"
    local package_type="$2"
    local package_version="$3"
    local normalized_name="$4"
    
    echo ""
    echo "Scanning: $package ($package_type)"
    echo "  Version: $package_version"
    
    local cache_file="$temp_cache_dir/${normalized_name}.json.gz"
    
    # Download CVE data
    if download_cve_data "$normalized_name" "$cache_file"; then
        # Decompress and analyze
        local cve_data
        cve_data=$(gunzip -c "$cache_file" 2>/dev/null)
        
        if [[ -n "$cve_data" ]]; then
            # Count total CVEs for this package
            local package_cve_count
            if command -v jq >/dev/null 2>&1; then
                package_cve_count=$(echo "$cve_data" | jq '. | length' 2>/dev/null || echo "0")
            else
                package_cve_count=$(echo "$cve_data" | python3 -c "import json, sys; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
            fi
            
            if [[ "$package_cve_count" -gt 0 ]]; then
                echo "  Found $package_cve_count CVEs in database, checking version relevance..."
                
                # Check each CVE
                local affected_cves=""
                local affected_count=0
                
                if command -v jq >/dev/null 2>&1; then
                    # Process with jq
                    while IFS= read -r cve_json; do
                        local cve_id severity score constraints
                        cve_id=$(echo "$cve_json" | jq -r '.id' 2>/dev/null)
                        severity=$(echo "$cve_json" | jq -r '.severity' 2>/dev/null)
                        score=$(echo "$cve_json" | jq -r '.score' 2>/dev/null)
                        constraints=$(echo "$cve_json" | jq -c '.version_constraints // {}' 2>/dev/null)
                        
                        # Check severity threshold
                        case "$CVE_SEVERITY_THRESHOLD" in
                            "CRITICAL")
                                [[ "$severity" != "CRITICAL" ]] && continue
                                ;;
                            "HIGH")
                                [[ "$severity" != "CRITICAL" && "$severity" != "HIGH" ]] && continue
                                ;;
                            "MEDIUM")
                                [[ "$severity" == "LOW" || "$severity" == "UNKNOWN" ]] && continue
                                ;;
                        esac
                        
                        # Check version constraints
                        local constraint_result
                        constraint_result=$(check_version_constraints "$package_version" "$constraints")
                        
                        if [[ "$constraint_result" == "AFFECTED:"* ]]; then
                            affected_count=$((affected_count + 1))
                            affected_cves="${affected_cves}    $cve_id - $severity (Score: $score)\n"
                            affected_cves="${affected_cves}      ${constraint_result#AFFECTED:}\n"
                            
                            # Log for compliance
                            echo "VULNERABILITY_DETECTED:$hostname|$current_user|$package|$package_version|$cve_id|$score|$severity|$package_type"
                            
                            total_cves_found=$((total_cves_found + 1))
                            if [[ "$severity" == "CRITICAL" || "$severity" == "HIGH" ]]; then
                                high_risk_cves=$((high_risk_cves + 1))
                            fi
                        elif [[ "$DEBUG_MODE" == "true" ]]; then
                            echo "  DEBUG: $cve_id - ${constraint_result#*:}" >&2
                        fi
                    done < <(echo "$cve_data" | jq -c '.[]' 2>/dev/null)
                else
                    # Python fallback
                    affected_count=$(python3 -c "
import json
import sys

data = json.loads('$cve_data')
installed_version = '$package_version'
threshold = '$CVE_SEVERITY_THRESHOLD'
severity_order = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1, 'UNKNOWN': 0}
threshold_score = severity_order.get(threshold, 0)
affected = 0

for cve in data:
    severity = cve.get('severity', 'UNKNOWN')
    if severity_order.get(severity, 0) < threshold_score:
        continue
    
    constraints = cve.get('version_constraints', {})
    if constraints.get('affects_all'):
        affected += 1
        print(f\"    {cve['id']} - {severity} (Score: {cve.get('score', 0)})\")
        print(f\"      Affects all versions\")
    elif constraints.get('max_version'):
        # Simple version check
        affected += 1
        print(f\"    {cve['id']} - {severity} (Score: {cve.get('score', 0)})\")
        print(f\"      Affects versions < {constraints['max_version']}\")

print(f'AFFECTED_COUNT:{affected}')
" 2>/dev/null)
                    
                    if [[ "$affected_count" =~ AFFECTED_COUNT:([0-9]+) ]]; then
                        affected_count="${BASH_REMATCH[1]}"
                    else
                        affected_count=0
                    fi
                fi
                
                if [[ $affected_count -gt 0 ]]; then
                    echo "  🚨 VULNERABILITIES FOUND: $affected_count CVEs affect version $package_version"
                    if [[ -n "$affected_cves" ]]; then
                        echo -e "$affected_cves"
                    fi
                    affected_packages=$((affected_packages + 1))
                else
                    echo "  ✅ No CVEs affect version $package_version"
                fi
            else
                echo "  ✅ No CVEs found for this package"
            fi
        else
            echo "  ⚠️  Failed to parse CVE data"
        fi
        
        rm -f "$cache_file"
    else
        echo "  ℹ️  No CVE data available for $normalized_name"
    fi
    
    scanned_packages=$((scanned_packages + 1))
}

# Function to scan all packages
scan_packages() {
    local package_list="$1"
    local package_type="$2"
    
    echo ""
    echo "=== SCANNING ${package_type^^} PACKAGES ==="
    
    if [[ -z "$package_list" ]]; then
        echo "No $package_type packages found"
        return 0
    fi
    
    local count=0
    while IFS= read -r package; do
        if [[ -n "$package" ]]; then
            count=$((count + 1))
            
            # Get package version
            local package_version
            package_version=$(get_package_version "$package" "$package_type")
            
            # Normalize package name
            local normalized_name
            normalized_name=$(normalize_package_name "$package")
            
            # Scan the package
            scan_package "$package" "$package_type" "$package_version" "$normalized_name"
        fi
    done <<< "$package_list"
}

# Main execution
if ! check_cve_database; then
    echo "Cannot proceed without CVE database access"
    exit 1
fi

# Get package lists
echo ""
echo "=== ENUMERATING HOMEBREW PACKAGES ==="

formula_list=$("$BREW_PATH" list --formula 2>/dev/null || echo "")
formula_count=0
if [[ -n "$formula_list" ]]; then
    formula_count=$(echo "$formula_list" | wc -l | tr -d ' ')
    echo "✅ Found $formula_count formulae"
fi

cask_list=$("$BREW_PATH" list --cask 2>/dev/null || echo "")
cask_count=0
if [[ -n "$cask_list" ]]; then
    cask_count=$(echo "$cask_list" | wc -l | tr -d ' ')
    echo "✅ Found $cask_count casks"
fi

total_packages=$((formula_count + cask_count))
echo "📊 TOTAL PACKAGES TO SCAN: $total_packages"

if [[ $total_packages -eq 0 ]]; then
    echo "COMPLIANCE_STATUS: COMPLIANT"
    echo "REASON: No Homebrew packages installed"
    exit 0
fi

# Scan packages
[[ $formula_count -gt 0 ]] && scan_packages "$formula_list" "formula"
[[ $cask_count -gt 0 ]] && scan_packages "$cask_list" "cask"

# Final report
echo ""
echo "=========================================="
echo "ACCURATE CVE SCAN REPORT"
echo "=========================================="
echo "Device: $hostname"
echo "User: $current_user"
echo "Scan Time: $timestamp"
echo ""
echo "SCAN SUMMARY:"
echo "  Total Packages: $total_packages"
echo "  Scanned Packages: $scanned_packages"
echo "  Packages with CVEs: $affected_packages"
echo ""
echo "VULNERABILITY SUMMARY:"
echo "  Total CVEs Found: $total_cves_found"
echo "  High/Critical CVEs: $high_risk_cves"

# Compliance determination
if [[ $high_risk_cves -gt 0 ]]; then
    echo ""
    echo "🚨 COMPLIANCE_STATUS: NON-COMPLIANT"
    echo "REASON: $high_risk_cves high/critical vulnerabilities affecting installed versions"
    echo "ACTION_REQUIRED: Update affected packages immediately"
    exit 1
elif [[ $total_cves_found -gt 5 ]]; then
    echo ""
    echo "⚠️  COMPLIANCE_STATUS: COMPLIANT_WITH_WARNINGS"
    echo "REASON: $total_cves_found vulnerabilities detected"
    echo "ACTION_REQUIRED: Review and update affected packages"
    exit 0
else
    echo ""
    echo "✅ COMPLIANCE_STATUS: COMPLIANT"
    echo "REASON: No significant vulnerabilities affecting installed versions"
    exit 0
fi